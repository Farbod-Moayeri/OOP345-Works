///////////////////////////////////////////////////////
//                  WorkShop 9 - Part 2
// Name: Farbod Moayeri
// Id: 134395227
// Email: fmoayeri2@myseneca.ca
// Section: NFF
// Date: 2023-11-25
///////////////////////////////////////////////////////
// I have done all the coding by myself and only copied
// the code that my professor provided to complete my 
// workshops and assignments.
///////////////////////////////////////////////////////



Q. In your reflection, include discussion on your observation of the computation times with three different values of the above parameters, and the number of threads used to do the calculations.

	When I ran those three different sleep_for functions, it increased how long it took to compute the average and variance on one thread but for each thread that was added, the amount of time it took to calculate those things
	decreased. I also noticed that without that command in the computeAvg and computeVar functions, the more threads that were added, the longer it took to compute. This brought me to the conclusion that perhaps using multiple
	threads is not the best solution if one thread can easily complete the workload and multiple thread manigment only increases the time computation takes rather than decreasing it.
Q. was there any benefit from using binary files in this workshop?

		yes, there was benefit from using binary files in the workshop. Firstly, binary files are more compact and they allow for faster reading and writing since the data doesnt need to be
	converted in any way. It is also easier logically to read from them as shown from the code below.

	It was incredibly easy to read from the file as long as I knew the order in which to read the information. The first four bytes were for the total items stored in the file and the
	rest of the data stored in the file was for each element of the array that is created by using total_items as the size of it.


std::ifstream file(filename, std::ios::binary);

	if (file)
	{
		file.read(reinterpret_cast<char*>(&total_items), sizeof(int));

		data = new int[total_items];

		file.read(reinterpret_cast<char*>(data), sizeof(int) * total_items);
	}


	file.close();
Q. why would be important to bind a function to its arguments, and how was it useful in this workshop?

		It is important because it is used to create a function object which can be invoked later by our threads. Basically it allows us to create a job for our threads to later do. It was useful
	in this workshop because we used std::bind to create function objects then gave the function objects with their arguments to each thread using emplace_back(). 

	
	First I created a function object using std::bind which bound the computeAvgFactor function with total_items as one of its parameters. The other parameters need arguments
	provided to them for the function object to be able to be invoked. Then I used a for loop to loop through the the threads and feed them with different arguments. This is why
	std::bind was useful for this workshop, it allows me to build different versions of the computeAvg function object by feeding it different arguments and then hand those
	function objects off to each thread to execute.

	std::vector<std::thread> threads;
	std::vector<double> temp(num_threads, 0.0);

	int partition_size{};

	auto computeAvg = std::bind(computeAvgFactor, std::placeholders::_1, std::placeholders::_2, total_items, std::placeholders::_3);

	for (int i = 0; i < num_threads; ++i) {
		partition_size = p_indices[i + 1] - p_indices[i];

		threads.emplace_back(computeAvg, data + p_indices[i], partition_size, std::ref(temp[i]));
		total_avg += temp[i];
	}

	for (auto& t : threads) {
		t.join();
	}
		
	total_avg = 0.0;

	for (const auto& avg : temp)
	{
		total_avg += avg;
	}
		
	
Q. the advantages of using multiple threads, and how did you accomplish multi-threading in this workshop?

		The advantages of using multiple threads is that they can be used to break down one massive task into a bunch of little ones, thereby completing the big task faster. Another
	advantage is that for applications that have a UI, it allows you to complete tasks in the background instead of freezing the UI to complete the task on the same thread as the UI.

	Multithreading was accomplished in this workshop by creating a vector of the type thread, then creating a new thread and feeding it a function object to execute. Once all threads
	had been supplied with the resource they were going to work with, they were join()'ed one by one (garenteed executed) and the parameter that was fed to them was cycled through to
	get the total_avg or total_var.

